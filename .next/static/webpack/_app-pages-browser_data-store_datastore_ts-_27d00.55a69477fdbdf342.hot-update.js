"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_data-store_datastore_ts-_27d00",{

/***/ "(app-pages-browser)/./lib/client-api.ts":
/*!***************************!*\
  !*** ./lib/client-api.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientAPI: function() { return /* binding */ ClientAPI; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ ClientAPI auto */ const ClientAPI = {\n    // TASKS\n    getTasks: async ()=>{\n        const res = await fetch(\"/api/tasks\");\n        if (!res.ok) throw new Error(\"Failed to fetch tasks\");\n        return await res.json();\n    },\n    getTaskById: async (id)=>{\n        const res = await fetch(\"/api/tasks/\".concat(id));\n        if (!res.ok) return null;\n        return await res.json();\n    },\n    upsertTask: async (task)=>{\n        const res = await fetch(\"/api/tasks\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(task)\n        });\n        if (!res.ok) throw new Error(\"Failed to save task\");\n        return await res.json();\n    },\n    deleteTask: async (id)=>{\n        const res = await fetch(\"/api/tasks/\".concat(id), {\n            method: \"DELETE\"\n        });\n        if (!res.ok) throw new Error(\"Failed to delete task\");\n    },\n    // QUEUED OPERATIONS (Safety belt for real money operations)\n    upsertTaskQueued: async function(task) {\n        let priority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const res = await fetch(\"/api/tasks/queued\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                task,\n                priority\n            })\n        });\n        if (!res.ok) throw new Error(\"Failed to queue task\");\n        const result = await res.json();\n        return result.queueId;\n    },\n    // ITEMS\n    getItems: async ()=>{\n        const res = await fetch(\"/api/items\");\n        if (!res.ok) throw new Error(\"Failed to fetch items\");\n        return await res.json();\n    },\n    getItemById: async (id)=>{\n        const res = await fetch(\"/api/items/\".concat(id));\n        if (!res.ok) return null;\n        return await res.json();\n    },\n    upsertItem: async (item)=>{\n        const res = await fetch(\"/api/items\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(item)\n        });\n        if (!res.ok) throw new Error(\"Failed to save item\");\n        return await res.json();\n    },\n    deleteItem: async (id)=>{\n        const res = await fetch(\"/api/items/\".concat(id), {\n            method: \"DELETE\"\n        });\n        if (!res.ok) throw new Error(\"Failed to delete item\");\n    },\n    upsertItemQueued: async function(item) {\n        let priority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const res = await fetch(\"/api/items/queued\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                item,\n                priority\n            })\n        });\n        if (!res.ok) throw new Error(\"Failed to queue item\");\n        const result = await res.json();\n        return result.queueId;\n    },\n    // SALES\n    getSales: async ()=>{\n        const res = await fetch(\"/api/sales\");\n        if (!res.ok) throw new Error(\"Failed to fetch sales\");\n        return await res.json();\n    },\n    getSaleById: async (id)=>{\n        const res = await fetch(\"/api/sales/\".concat(id));\n        if (!res.ok) return null;\n        return await res.json();\n    },\n    upsertSale: async (sale)=>{\n        const res = await fetch(\"/api/sales\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(sale)\n        });\n        if (!res.ok) throw new Error(\"Failed to save sale\");\n        return await res.json();\n    },\n    deleteSale: async (id)=>{\n        const res = await fetch(\"/api/sales/\".concat(id), {\n            method: \"DELETE\"\n        });\n        if (!res.ok) throw new Error(\"Failed to delete sale\");\n    },\n    upsertSaleQueued: async function(sale) {\n        let priority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const res = await fetch(\"/api/sales/queued\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                sale,\n                priority\n            })\n        });\n        if (!res.ok) throw new Error(\"Failed to queue sale\");\n        const result = await res.json();\n        return result.queueId;\n    },\n    // FINANCIALS\n    getFinancialRecords: async ()=>{\n        const res = await fetch(\"/api/financials\");\n        if (!res.ok) throw new Error(\"Failed to fetch financials\");\n        return await res.json();\n    },\n    getFinancialRecordById: async (id)=>{\n        const res = await fetch(\"/api/financials/\".concat(id));\n        if (!res.ok) return null;\n        return await res.json();\n    },\n    upsertFinancialRecord: async (record)=>{\n        const res = await fetch(\"/api/financials\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(record)\n        });\n        if (!res.ok) throw new Error(\"Failed to save financial\");\n        return await res.json();\n    },\n    deleteFinancialRecord: async (id)=>{\n        const res = await fetch(\"/api/financials/\".concat(id), {\n            method: \"DELETE\"\n        });\n        if (!res.ok) throw new Error(\"Failed to delete financial\");\n    },\n    upsertFinancialRecordQueued: async function(record) {\n        let priority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const res = await fetch(\"/api/financials/queued\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                record,\n                priority\n            })\n        });\n        if (!res.ok) throw new Error(\"Failed to queue financial record\");\n        const result = await res.json();\n        return result.queueId;\n    },\n    // CHARACTERS\n    getCharacters: async ()=>{\n        const res = await fetch(\"/api/characters\");\n        if (!res.ok) throw new Error(\"Failed to fetch characters\");\n        return await res.json();\n    },\n    getCharacterById: async (id)=>{\n        const res = await fetch(\"/api/characters/\".concat(id));\n        if (!res.ok) return null;\n        return await res.json();\n    },\n    upsertCharacter: async (character)=>{\n        const res = await fetch(\"/api/characters\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(character)\n        });\n        if (!res.ok) throw new Error(\"Failed to save character\");\n        return await res.json();\n    },\n    deleteCharacter: async (id)=>{\n        const res = await fetch(\"/api/characters/\".concat(id), {\n            method: \"DELETE\"\n        });\n        if (!res.ok) throw new Error(\"Failed to delete character\");\n    },\n    // PLAYERS\n    getPlayers: async ()=>{\n        const res = await fetch(\"/api/players\");\n        if (!res.ok) throw new Error(\"Failed to fetch players\");\n        return await res.json();\n    },\n    getPlayerById: async (id)=>{\n        const res = await fetch(\"/api/players/\".concat(id));\n        if (!res.ok) return null;\n        return await res.json();\n    },\n    upsertPlayer: async (player)=>{\n        const res = await fetch(\"/api/players\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(player)\n        });\n        if (!res.ok) throw new Error(\"Failed to save player\");\n        return await res.json();\n    },\n    deletePlayer: async (id)=>{\n        const res = await fetch(\"/api/players/\".concat(id), {\n            method: \"DELETE\"\n        });\n        if (!res.ok) throw new Error(\"Failed to delete player\");\n    },\n    // LINKS\n    getLinksFor: async (params)=>{\n        const res = await fetch(\"/api/links?entityType=\".concat(params.type, \"&entityId=\").concat(params.id));\n        if (!res.ok) {\n            console.error(\"Failed to fetch links\");\n            return [];\n        }\n        return await res.json();\n    },\n    getAllLinks: async ()=>{\n        const res = await fetch(\"/api/links\");\n        if (!res.ok) {\n            console.error(\"Failed to fetch all links\");\n            return [];\n        }\n        return await res.json();\n    },\n    removeLink: async (linkId)=>{\n        const res = await fetch(\"/api/links/\".concat(linkId), {\n            method: \"DELETE\"\n        });\n        if (!res.ok) throw new Error(\"Failed to remove link\");\n    },\n    removeLogEntry: async (logType, entityId)=>{\n        const res = await fetch(\"/api/\".concat(logType, \"-log\"), {\n            method: \"DELETE\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                entityId\n            })\n        });\n        if (!res.ok) {\n            return {\n                success: false,\n                message: \"Failed to remove \".concat(logType, \" log entry\")\n            };\n        }\n        return await res.json();\n    },\n    // SITES\n    getSites: async ()=>{\n        const res = await fetch(\"/api/sites\");\n        if (!res.ok) throw new Error(\"Failed to fetch sites\");\n        return await res.json();\n    },\n    getSiteById: async (id)=>{\n        const res = await fetch(\"/api/sites/\".concat(id));\n        if (!res.ok) return null;\n        return await res.json();\n    },\n    upsertSite: async (site)=>{\n        const res = await fetch(\"/api/sites\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(site)\n        });\n        if (!res.ok) throw new Error(\"Failed to save site\");\n        return await res.json();\n    },\n    deleteSite: async (id)=>{\n        const res = await fetch(\"/api/sites/\".concat(id), {\n            method: \"DELETE\"\n        });\n        if (!res.ok) throw new Error(\"Failed to delete site\");\n    },\n    // Placeholder methods for features not yet implemented\n    getAccount: async (id)=>{\n        throw new Error(\"Account entity not yet implemented in KV-only system\");\n    },\n    upsertAccount: async (account)=>{\n        throw new Error(\"Account entity not yet implemented in KV-only system\");\n    },\n    // ASSETS MANAGEMENT\n    getCompanyAssets: async ()=>{\n        const res = await fetch(\"/api/assets/company\");\n        if (!res.ok) throw new Error(\"Failed to fetch company assets\");\n        return await res.json();\n    },\n    saveCompanyAssets: async (assets)=>{\n        const res = await fetch(\"/api/assets/company\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(assets)\n        });\n        if (!res.ok) throw new Error(\"Failed to save company assets\");\n    },\n    getPersonalAssets: async ()=>{\n        const res = await fetch(\"/api/assets/personal\");\n        if (!res.ok) throw new Error(\"Failed to fetch personal assets\");\n        return await res.json();\n    },\n    savePersonalAssets: async (assets)=>{\n        const res = await fetch(\"/api/assets/personal\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(assets)\n        });\n        if (!res.ok) throw new Error(\"Failed to save personal assets\");\n    },\n    // CONVERSION RATES\n    getConversionRates: async ()=>{\n        const res = await fetch(\"/api/settings/conversion-rates\");\n        if (!res.ok) throw new Error(\"Failed to fetch conversion rates\");\n        return await res.json();\n    },\n    saveConversionRates: async (rates)=>{\n        const res = await fetch(\"/api/settings/conversion-rates\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(rates)\n        });\n        if (!res.ok) throw new Error(\"Failed to save conversion rates\");\n    },\n    // LEGACY COMPATIBILITY\n    getPointsConversionRates: async ()=>{\n        return await ClientAPI.getConversionRates();\n    },\n    // UTILITY HELPERS (client-side calculations)\n    getItemTotalQuantity: (itemId, items)=>{\n        const item = items.find((i)=>i.id === itemId);\n        if (!item) return 0;\n        // Sum up all stock across all sites using StockPoint[] array\n        return item.stock.reduce((sum, sp)=>sum + sp.quantity, 0);\n    },\n    updateStockAtSite: async (itemId, siteId, quantity)=>{\n        // Get current item\n        const currentItem = await ClientAPI.getItemById(itemId);\n        if (!currentItem) throw new Error(\"Item not found\");\n        // Update stock at site using StockPoint[] array\n        const stockIndex = currentItem.stock.findIndex((sp)=>sp.siteId === siteId);\n        const updatedStock = [\n            ...currentItem.stock\n        ];\n        if (stockIndex >= 0) {\n            if (quantity === 0) {\n                updatedStock.splice(stockIndex, 1);\n            } else {\n                updatedStock[stockIndex] = {\n                    siteId,\n                    quantity\n                };\n            }\n        } else if (quantity > 0) {\n            updatedStock.push({\n                siteId,\n                quantity\n            });\n        }\n        // Save updated item\n        return await ClientAPI.upsertItem({\n            ...currentItem,\n            stock: updatedStock\n        });\n    },\n    convertPointsToJ$: function(points) {\n        let conversionRate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;\n        // Default conversion rate: 100 points = 1 J$\n        return Math.floor(points / conversionRate);\n    },\n    // Additional utility methods for inventory\n    getItemsByModel: (items)=>{\n        const grouped = {};\n        items.forEach((item)=>{\n            const key = \"\".concat(item.type, \"|\").concat(item.subItemType || \"\", \"|\").concat(item.name, \"|\").concat(item.collection || \"\");\n            if (!grouped[key]) {\n                grouped[key] = [];\n            }\n            grouped[key].push(item);\n        });\n        return grouped;\n    },\n    getModelTotalQuantity: (items, selectedSiteIds)=>{\n        return items.reduce((total, item)=>{\n            if (selectedSiteIds.size === 0) {\n                return total + item.stock.reduce((sum, sp)=>sum + sp.quantity, 0);\n            }\n            return total + item.stock.filter((sp)=>selectedSiteIds.has(sp.siteId)).reduce((sum, sp)=>sum + sp.quantity, 0);\n        }, 0);\n    },\n    getItemModelKey: (item)=>{\n        return \"\".concat(item.type, \"|\").concat(item.subItemType || \"\", \"|\").concat(item.name, \"|\").concat(item.collection || \"\");\n    },\n    // Financial records filtering methods\n    getFinancialRecordsByMonth: async (year, month, type)=>{\n        const allRecords = await ClientAPI.getFinancialRecords();\n        return allRecords.filter((record)=>record.year === year && record.month === month && record.type === type);\n    },\n    // Additional methods needed by components\n    getQuantityAtSite: (item, siteId)=>{\n        var _item_stock_find;\n        return ((_item_stock_find = item.stock.find((sp)=>sp.siteId === siteId)) === null || _item_stock_find === void 0 ? void 0 : _item_stock_find.quantity) || 0;\n    },\n    moveItemsBetweenSites: async (item, fromSiteId, toSiteId, quantity)=>{\n        const updatedItem = {\n            ...item\n        };\n        // Find source stock\n        const sourceStockIndex = updatedItem.stock.findIndex((sp)=>sp.siteId === fromSiteId);\n        if (sourceStockIndex === -1) {\n            throw new Error(\"Item not found at source site: \".concat(fromSiteId));\n        }\n        const sourceStock = updatedItem.stock[sourceStockIndex];\n        if (sourceStock.quantity < quantity) {\n            throw new Error(\"Insufficient quantity at source. Available: \".concat(sourceStock.quantity, \", Requested: \").concat(quantity));\n        }\n        // Reduce source quantity\n        if (sourceStock.quantity === quantity) {\n            // Remove stock point if moving all items\n            updatedItem.stock = updatedItem.stock.filter((_, i)=>i !== sourceStockIndex);\n        } else {\n            // Reduce quantity\n            updatedItem.stock[sourceStockIndex] = {\n                ...sourceStock,\n                quantity: sourceStock.quantity - quantity\n            };\n        }\n        // Add to destination (or increase existing stock)\n        const destStockIndex = updatedItem.stock.findIndex((sp)=>sp.siteId === toSiteId);\n        if (destStockIndex >= 0) {\n            // Increase existing stock\n            updatedItem.stock[destStockIndex] = {\n                ...updatedItem.stock[destStockIndex],\n                quantity: updatedItem.stock[destStockIndex].quantity + quantity\n            };\n        } else {\n            // Add new stock point\n            updatedItem.stock.push({\n                siteId: toSiteId,\n                quantity: quantity\n            });\n        }\n        return updatedItem;\n    },\n    bulkImportItems: async (items)=>{\n        try {\n            for (const item of items){\n                await ClientAPI.upsertItem(item);\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Failed to bulk import items:\", error);\n            return false;\n        }\n    },\n    bulkMergeItems: async (items)=>{\n        console.warn(\"[ClientAPI] bulkMergeItems not implemented yet\");\n        return false;\n    },\n    bulkAddItemsOnly: async (items)=>{\n        console.warn(\"[ClientAPI] bulkAddItemsOnly not implemented yet\");\n        return {\n            success: false,\n            addedCount: 0\n        };\n    },\n    getAccounts: async ()=>{\n        console.warn(\"[ClientAPI] getAccounts not implemented yet\");\n        return [];\n    },\n    // BULK OPERATION LOGGING\n    logBulkImport: async (entityType, details)=>{\n        const res = await fetch(\"/api/logs/bulk\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                entityType,\n                operation: \"import\",\n                ...details\n            })\n        });\n        if (!res.ok) throw new Error(\"Failed to log bulk import\");\n    },\n    logBulkExport: async (entityType, details)=>{\n        const res = await fetch(\"/api/logs/bulk\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                entityType,\n                operation: \"export\",\n                ...details\n            })\n        });\n        if (!res.ok) throw new Error(\"Failed to log bulk export\");\n    },\n    // QUEUE MANAGEMENT\n    getQueueStatus: async ()=>{\n        const res = await fetch(\"/api/queue/status\");\n        if (!res.ok) throw new Error(\"Failed to get queue status\");\n        return await res.json();\n    },\n    configureQueue: async (options)=>{\n        const res = await fetch(\"/api/queue/configure\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(options)\n        });\n        if (!res.ok) throw new Error(\"Failed to configure queue\");\n    },\n    stopQueue: async ()=>{\n        const res = await fetch(\"/api/queue/stop\", {\n            method: \"POST\"\n        });\n        if (!res.ok) throw new Error(\"Failed to stop queue\");\n    },\n    clearQueue: async ()=>{\n        const res = await fetch(\"/api/queue/clear\", {\n            method: \"POST\"\n        });\n        if (!res.ok) throw new Error(\"Failed to clear queue\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dkI7SUFFQXVJLGdCQUFnQixPQUFPQztRQUNyQixNQUFNNUksTUFBTSxNQUFNQyxNQUFNLHdCQUF3QjtZQUM5Q1EsUUFBUTtZQUNSQyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDK0g7UUFDdkI7UUFDQSxJQUFJLENBQUM1SSxJQUFJRSxFQUFFLEVBQUUsTUFBTSxJQUFJQyxNQUFNO0lBQy9CO0lBRUEwSSxXQUFXO1FBQ1QsTUFBTTdJLE1BQU0sTUFBTUMsTUFBTSxtQkFBbUI7WUFBRVEsUUFBUTtRQUFPO1FBQzVELElBQUksQ0FBQ1QsSUFBSUUsRUFBRSxFQUFFLE1BQU0sSUFBSUMsTUFBTTtJQUMvQjtJQUVBMkksWUFBWTtRQUNWLE1BQU05SSxNQUFNLE1BQU1DLE1BQU0sb0JBQW9CO1lBQUVRLFFBQVE7UUFBTztRQUM3RCxJQUFJLENBQUNULElBQUlFLEVBQUUsRUFBRSxNQUFNLElBQUlDLE1BQU07SUFDL0I7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jbGllbnQtYXBpLnRzP2NmYzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHR5cGUgeyBUYXNrLCBJdGVtLCBTYWxlLCBGaW5hbmNpYWxSZWNvcmQsIENoYXJhY3RlciwgUGxheWVyLCBTaXRlIH0gZnJvbSAnQC90eXBlcy9lbnRpdGllcyc7XHJcblxyXG5leHBvcnQgY29uc3QgQ2xpZW50QVBJID0ge1xyXG4gIC8vIFRBU0tTXHJcbiAgZ2V0VGFza3M6IGFzeW5jICgpOiBQcm9taXNlPFRhc2tbXT4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvdGFza3MnKTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCB0YXNrcycpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSxcclxuICBcclxuICBnZXRUYXNrQnlJZDogYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPFRhc2sgfCBudWxsPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2FwaS90YXNrcy8ke2lkfWApO1xyXG4gICAgaWYgKCFyZXMub2spIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSxcclxuICBcclxuICB1cHNlcnRUYXNrOiBhc3luYyAodGFzazogVGFzayk6IFByb21pc2U8VGFzaz4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvdGFza3MnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGFzaylcclxuICAgIH0pO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgdGFzaycpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSxcclxuICBcclxuICBkZWxldGVUYXNrOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvdGFza3MvJHtpZH1gLCB7IG1ldGhvZDogJ0RFTEVURScgfSk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIHRhc2snKTtcclxuICB9LFxyXG5cclxuICAvLyBRVUVVRUQgT1BFUkFUSU9OUyAoU2FmZXR5IGJlbHQgZm9yIHJlYWwgbW9uZXkgb3BlcmF0aW9ucylcclxuICB1cHNlcnRUYXNrUXVldWVkOiBhc3luYyAodGFzazogVGFzaywgcHJpb3JpdHk6IG51bWJlciA9IDEpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvdGFza3MvcXVldWVkJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdGFzaywgcHJpb3JpdHkgfSlcclxuICAgIH0pO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHF1ZXVlIHRhc2snKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0LnF1ZXVlSWQ7XHJcbiAgfSxcclxuICBcclxuICAvLyBJVEVNU1xyXG4gIGdldEl0ZW1zOiBhc3luYyAoKTogUHJvbWlzZTxJdGVtW10+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL2l0ZW1zJyk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggaXRlbXMnKTtcclxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xyXG4gIH0sXHJcbiAgXHJcbiAgZ2V0SXRlbUJ5SWQ6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxJdGVtIHwgbnVsbD4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvaXRlbXMvJHtpZH1gKTtcclxuICAgIGlmICghcmVzLm9rKSByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xyXG4gIH0sXHJcbiAgXHJcbiAgdXBzZXJ0SXRlbTogYXN5bmMgKGl0ZW06IEl0ZW0pOiBQcm9taXNlPEl0ZW0+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL2l0ZW1zJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGl0ZW0pXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGl0ZW0nKTtcclxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xyXG4gIH0sXHJcbiAgXHJcbiAgZGVsZXRlSXRlbTogYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2l0ZW1zLyR7aWR9YCwgeyBtZXRob2Q6ICdERUxFVEUnIH0pO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBpdGVtJyk7XHJcbiAgfSxcclxuXHJcbiAgdXBzZXJ0SXRlbVF1ZXVlZDogYXN5bmMgKGl0ZW06IEl0ZW0sIHByaW9yaXR5OiBudW1iZXIgPSAxKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL2l0ZW1zL3F1ZXVlZCcsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGl0ZW0sIHByaW9yaXR5IH0pXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBxdWV1ZSBpdGVtJyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgcmV0dXJuIHJlc3VsdC5xdWV1ZUlkO1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gU0FMRVNcclxuICBnZXRTYWxlczogYXN5bmMgKCk6IFByb21pc2U8U2FsZVtdPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYWxlcycpO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHNhbGVzJyk7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG4gIFxyXG4gIGdldFNhbGVCeUlkOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8U2FsZSB8IG51bGw+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL3NhbGVzLyR7aWR9YCk7XHJcbiAgICBpZiAoIXJlcy5vaykgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG4gIFxyXG4gIHVwc2VydFNhbGU6IGFzeW5jIChzYWxlOiBTYWxlKTogUHJvbWlzZTxTYWxlPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYWxlcycsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShzYWxlKVxyXG4gICAgfSk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2F2ZSBzYWxlJyk7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG4gIFxyXG4gIGRlbGV0ZVNhbGU6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9zYWxlcy8ke2lkfWAsIHsgbWV0aG9kOiAnREVMRVRFJyB9KTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgc2FsZScpO1xyXG4gIH0sXHJcblxyXG4gIHVwc2VydFNhbGVRdWV1ZWQ6IGFzeW5jIChzYWxlOiBTYWxlLCBwcmlvcml0eTogbnVtYmVyID0gMSk6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYWxlcy9xdWV1ZWQnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzYWxlLCBwcmlvcml0eSB9KVxyXG4gICAgfSk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcXVldWUgc2FsZScpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzLmpzb24oKTtcclxuICAgIHJldHVybiByZXN1bHQucXVldWVJZDtcclxuICB9LFxyXG4gIFxyXG4gIC8vIEZJTkFOQ0lBTFNcclxuICBnZXRGaW5hbmNpYWxSZWNvcmRzOiBhc3luYyAoKTogUHJvbWlzZTxGaW5hbmNpYWxSZWNvcmRbXT4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvZmluYW5jaWFscycpO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGZpbmFuY2lhbHMnKTtcclxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xyXG4gIH0sXHJcbiAgXHJcbiAgZ2V0RmluYW5jaWFsUmVjb3JkQnlJZDogYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPEZpbmFuY2lhbFJlY29yZCB8IG51bGw+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2ZpbmFuY2lhbHMvJHtpZH1gKTtcclxuICAgIGlmICghcmVzLm9rKSByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xyXG4gIH0sXHJcbiAgXHJcbiAgdXBzZXJ0RmluYW5jaWFsUmVjb3JkOiBhc3luYyAocmVjb3JkOiBGaW5hbmNpYWxSZWNvcmQpOiBQcm9taXNlPEZpbmFuY2lhbFJlY29yZD4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvZmluYW5jaWFscycsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZWNvcmQpXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGZpbmFuY2lhbCcpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSxcclxuICBcclxuICBkZWxldGVGaW5hbmNpYWxSZWNvcmQ6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9maW5hbmNpYWxzLyR7aWR9YCwgeyBtZXRob2Q6ICdERUxFVEUnIH0pO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBmaW5hbmNpYWwnKTtcclxuICB9LFxyXG5cclxuICB1cHNlcnRGaW5hbmNpYWxSZWNvcmRRdWV1ZWQ6IGFzeW5jIChyZWNvcmQ6IEZpbmFuY2lhbFJlY29yZCwgcHJpb3JpdHk6IG51bWJlciA9IDEpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvZmluYW5jaWFscy9xdWV1ZWQnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyByZWNvcmQsIHByaW9yaXR5IH0pXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBxdWV1ZSBmaW5hbmNpYWwgcmVjb3JkJyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgcmV0dXJuIHJlc3VsdC5xdWV1ZUlkO1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gQ0hBUkFDVEVSU1xyXG4gIGdldENoYXJhY3RlcnM6IGFzeW5jICgpOiBQcm9taXNlPENoYXJhY3RlcltdPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGFyYWN0ZXJzJyk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggY2hhcmFjdGVycycpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSxcclxuICBcclxuICBnZXRDaGFyYWN0ZXJCeUlkOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8Q2hhcmFjdGVyIHwgbnVsbD4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvY2hhcmFjdGVycy8ke2lkfWApO1xyXG4gICAgaWYgKCFyZXMub2spIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSxcclxuICBcclxuICB1cHNlcnRDaGFyYWN0ZXI6IGFzeW5jIChjaGFyYWN0ZXI6IENoYXJhY3Rlcik6IFByb21pc2U8Q2hhcmFjdGVyPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGFyYWN0ZXJzJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNoYXJhY3RlcilcclxuICAgIH0pO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgY2hhcmFjdGVyJyk7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG4gIFxyXG4gIGRlbGV0ZUNoYXJhY3RlcjogYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2NoYXJhY3RlcnMvJHtpZH1gLCB7IG1ldGhvZDogJ0RFTEVURScgfSk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGNoYXJhY3RlcicpO1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gUExBWUVSU1xyXG4gIGdldFBsYXllcnM6IGFzeW5jICgpOiBQcm9taXNlPFBsYXllcltdPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9wbGF5ZXJzJyk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcGxheWVycycpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSxcclxuICBcclxuICBnZXRQbGF5ZXJCeUlkOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8UGxheWVyIHwgbnVsbD4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvcGxheWVycy8ke2lkfWApO1xyXG4gICAgaWYgKCFyZXMub2spIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSxcclxuICBcclxuICB1cHNlcnRQbGF5ZXI6IGFzeW5jIChwbGF5ZXI6IFBsYXllcik6IFByb21pc2U8UGxheWVyPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9wbGF5ZXJzJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBsYXllcilcclxuICAgIH0pO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgcGxheWVyJyk7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG4gIFxyXG4gIGRlbGV0ZVBsYXllcjogYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL3BsYXllcnMvJHtpZH1gLCB7IG1ldGhvZDogJ0RFTEVURScgfSk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIHBsYXllcicpO1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gTElOS1NcclxuICBnZXRMaW5rc0ZvcjogYXN5bmMgKHBhcmFtczogeyB0eXBlOiBzdHJpbmc7IGlkOiBzdHJpbmcgfSk6IFByb21pc2U8YW55W10+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2xpbmtzP2VudGl0eVR5cGU9JHtwYXJhbXMudHlwZX0mZW50aXR5SWQ9JHtwYXJhbXMuaWR9YCk7XHJcbiAgICBpZiAoIXJlcy5vaykge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbGlua3MnKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0QWxsTGlua3M6IGFzeW5jICgpOiBQcm9taXNlPGFueVtdPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9saW5rcycpO1xyXG4gICAgaWYgKCFyZXMub2spIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIGFsbCBsaW5rcycpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG5cclxuICByZW1vdmVMaW5rOiBhc3luYyAobGlua0lkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2xpbmtzLyR7bGlua0lkfWAsIHsgbWV0aG9kOiAnREVMRVRFJyB9KTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZW1vdmUgbGluaycpO1xyXG4gIH0sXHJcblxyXG4gIHJlbW92ZUxvZ0VudHJ5OiBhc3luYyAobG9nVHlwZTogc3RyaW5nLCBlbnRpdHlJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfT4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvJHtsb2dUeXBlfS1sb2dgLCB7XHJcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVudGl0eUlkIH0pXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzLm9rKSB7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiBgRmFpbGVkIHRvIHJlbW92ZSAke2xvZ1R5cGV9IGxvZyBlbnRyeWAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gU0lURVNcclxuICBnZXRTaXRlczogYXN5bmMgKCk6IFByb21pc2U8U2l0ZVtdPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9zaXRlcycpO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHNpdGVzJyk7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG4gIFxyXG4gIGdldFNpdGVCeUlkOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8U2l0ZSB8IG51bGw+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL3NpdGVzLyR7aWR9YCk7XHJcbiAgICBpZiAoIXJlcy5vaykgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG4gIFxyXG4gIHVwc2VydFNpdGU6IGFzeW5jIChzaXRlOiBTaXRlKTogUHJvbWlzZTxTaXRlPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9zaXRlcycsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShzaXRlKVxyXG4gICAgfSk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2F2ZSBzaXRlJyk7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG4gIFxyXG4gIGRlbGV0ZVNpdGU6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9zaXRlcy8ke2lkfWAsIHsgbWV0aG9kOiAnREVMRVRFJyB9KTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgc2l0ZScpO1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gUGxhY2Vob2xkZXIgbWV0aG9kcyBmb3IgZmVhdHVyZXMgbm90IHlldCBpbXBsZW1lbnRlZFxyXG4gIGdldEFjY291bnQ6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+ID0+IHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBlbnRpdHkgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBLVi1vbmx5IHN5c3RlbScpO1xyXG4gIH0sXHJcbiAgXHJcbiAgdXBzZXJ0QWNjb3VudDogYXN5bmMgKGFjY291bnQ6IGFueSk6IFByb21pc2U8YW55PiA9PiB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgZW50aXR5IG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gS1Ytb25seSBzeXN0ZW0nKTtcclxuICB9LFxyXG4gIFxyXG4gIC8vIEFTU0VUUyBNQU5BR0VNRU5UXHJcbiAgZ2V0Q29tcGFueUFzc2V0czogYXN5bmMgKCk6IFByb21pc2U8YW55PiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9hc3NldHMvY29tcGFueScpO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGNvbXBhbnkgYXNzZXRzJyk7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG4gIFxyXG4gIHNhdmVDb21wYW55QXNzZXRzOiBhc3luYyAoYXNzZXRzOiBhbnkpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL2Fzc2V0cy9jb21wYW55Jywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGFzc2V0cylcclxuICAgIH0pO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgY29tcGFueSBhc3NldHMnKTtcclxuICB9LFxyXG4gIFxyXG4gIGdldFBlcnNvbmFsQXNzZXRzOiBhc3luYyAoKTogUHJvbWlzZTxhbnk+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL2Fzc2V0cy9wZXJzb25hbCcpO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHBlcnNvbmFsIGFzc2V0cycpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSxcclxuICBcclxuICBzYXZlUGVyc29uYWxBc3NldHM6IGFzeW5jIChhc3NldHM6IGFueSk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvYXNzZXRzL3BlcnNvbmFsJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGFzc2V0cylcclxuICAgIH0pO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgcGVyc29uYWwgYXNzZXRzJyk7XHJcbiAgfSxcclxuICBcclxuICAvLyBDT05WRVJTSU9OIFJBVEVTXHJcbiAgZ2V0Q29udmVyc2lvblJhdGVzOiBhc3luYyAoKTogUHJvbWlzZTxhbnk+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL3NldHRpbmdzL2NvbnZlcnNpb24tcmF0ZXMnKTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBjb252ZXJzaW9uIHJhdGVzJyk7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9LFxyXG4gIFxyXG4gIHNhdmVDb252ZXJzaW9uUmF0ZXM6IGFzeW5jIChyYXRlczogYW55KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9zZXR0aW5ncy9jb252ZXJzaW9uLXJhdGVzJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJhdGVzKVxyXG4gICAgfSk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2F2ZSBjb252ZXJzaW9uIHJhdGVzJyk7XHJcbiAgfSxcclxuICBcclxuICAvLyBMRUdBQ1kgQ09NUEFUSUJJTElUWVxyXG4gIGdldFBvaW50c0NvbnZlcnNpb25SYXRlczogYXN5bmMgKCk6IFByb21pc2U8YW55PiA9PiB7XHJcbiAgICByZXR1cm4gYXdhaXQgQ2xpZW50QVBJLmdldENvbnZlcnNpb25SYXRlcygpO1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVVRJTElUWSBIRUxQRVJTIChjbGllbnQtc2lkZSBjYWxjdWxhdGlvbnMpXHJcbiAgZ2V0SXRlbVRvdGFsUXVhbnRpdHk6IChpdGVtSWQ6IHN0cmluZywgaXRlbXM6IEl0ZW1bXSk6IG51bWJlciA9PiB7XHJcbiAgICBjb25zdCBpdGVtID0gaXRlbXMuZmluZChpID0+IGkuaWQgPT09IGl0ZW1JZCk7XHJcbiAgICBpZiAoIWl0ZW0pIHJldHVybiAwO1xyXG4gICAgXHJcbiAgICAvLyBTdW0gdXAgYWxsIHN0b2NrIGFjcm9zcyBhbGwgc2l0ZXMgdXNpbmcgU3RvY2tQb2ludFtdIGFycmF5XHJcbiAgICByZXR1cm4gaXRlbS5zdG9jay5yZWR1Y2UoKHN1bSwgc3ApID0+IHN1bSArIHNwLnF1YW50aXR5LCAwKTtcclxuICB9LFxyXG4gIFxyXG4gIHVwZGF0ZVN0b2NrQXRTaXRlOiBhc3luYyAoaXRlbUlkOiBzdHJpbmcsIHNpdGVJZDogc3RyaW5nLCBxdWFudGl0eTogbnVtYmVyKTogUHJvbWlzZTxJdGVtPiA9PiB7XHJcbiAgICAvLyBHZXQgY3VycmVudCBpdGVtXHJcbiAgICBjb25zdCBjdXJyZW50SXRlbSA9IGF3YWl0IENsaWVudEFQSS5nZXRJdGVtQnlJZChpdGVtSWQpO1xyXG4gICAgaWYgKCFjdXJyZW50SXRlbSkgdGhyb3cgbmV3IEVycm9yKCdJdGVtIG5vdCBmb3VuZCcpO1xyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgc3RvY2sgYXQgc2l0ZSB1c2luZyBTdG9ja1BvaW50W10gYXJyYXlcclxuICAgIGNvbnN0IHN0b2NrSW5kZXggPSBjdXJyZW50SXRlbS5zdG9jay5maW5kSW5kZXgoc3AgPT4gc3Auc2l0ZUlkID09PSBzaXRlSWQpO1xyXG4gICAgY29uc3QgdXBkYXRlZFN0b2NrID0gWy4uLmN1cnJlbnRJdGVtLnN0b2NrXTtcclxuICAgIFxyXG4gICAgaWYgKHN0b2NrSW5kZXggPj0gMCkge1xyXG4gICAgICBpZiAocXVhbnRpdHkgPT09IDApIHtcclxuICAgICAgICB1cGRhdGVkU3RvY2suc3BsaWNlKHN0b2NrSW5kZXgsIDEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVwZGF0ZWRTdG9ja1tzdG9ja0luZGV4XSA9IHsgc2l0ZUlkLCBxdWFudGl0eSB9O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHF1YW50aXR5ID4gMCkge1xyXG4gICAgICB1cGRhdGVkU3RvY2sucHVzaCh7IHNpdGVJZCwgcXVhbnRpdHkgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNhdmUgdXBkYXRlZCBpdGVtXHJcbiAgICByZXR1cm4gYXdhaXQgQ2xpZW50QVBJLnVwc2VydEl0ZW0oe1xyXG4gICAgICAuLi5jdXJyZW50SXRlbSxcclxuICAgICAgc3RvY2s6IHVwZGF0ZWRTdG9ja1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICBcclxuICBjb252ZXJ0UG9pbnRzVG9KJDogKHBvaW50czogbnVtYmVyLCBjb252ZXJzaW9uUmF0ZTogbnVtYmVyID0gMTAwKTogbnVtYmVyID0+IHtcclxuICAgIC8vIERlZmF1bHQgY29udmVyc2lvbiByYXRlOiAxMDAgcG9pbnRzID0gMSBKJFxyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IocG9pbnRzIC8gY29udmVyc2lvblJhdGUpO1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gQWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgZm9yIGludmVudG9yeVxyXG4gIGdldEl0ZW1zQnlNb2RlbDogKGl0ZW1zOiBJdGVtW10pOiBSZWNvcmQ8c3RyaW5nLCBJdGVtW10+ID0+IHtcclxuICAgIGNvbnN0IGdyb3VwZWQ6IFJlY29yZDxzdHJpbmcsIEl0ZW1bXT4gPSB7fTtcclxuICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIGNvbnN0IGtleSA9IGAke2l0ZW0udHlwZX18JHtpdGVtLnN1Ykl0ZW1UeXBlIHx8ICcnfXwke2l0ZW0ubmFtZX18JHtpdGVtLmNvbGxlY3Rpb24gfHwgJyd9YDtcclxuICAgICAgaWYgKCFncm91cGVkW2tleV0pIHtcclxuICAgICAgICBncm91cGVkW2tleV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBncm91cGVkW2tleV0ucHVzaChpdGVtKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGdyb3VwZWQ7XHJcbiAgfSxcclxuICBcclxuICBnZXRNb2RlbFRvdGFsUXVhbnRpdHk6IChpdGVtczogSXRlbVtdLCBzZWxlY3RlZFNpdGVJZHM6IFNldDxzdHJpbmc+KTogbnVtYmVyID0+IHtcclxuICAgIHJldHVybiBpdGVtcy5yZWR1Y2UoKHRvdGFsLCBpdGVtKSA9PiB7XHJcbiAgICAgIGlmIChzZWxlY3RlZFNpdGVJZHMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB0b3RhbCArIGl0ZW0uc3RvY2sucmVkdWNlKChzdW0sIHNwKSA9PiBzdW0gKyBzcC5xdWFudGl0eSwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRvdGFsICsgaXRlbS5zdG9ja1xyXG4gICAgICAgIC5maWx0ZXIoc3AgPT4gc2VsZWN0ZWRTaXRlSWRzLmhhcyhzcC5zaXRlSWQpKVxyXG4gICAgICAgIC5yZWR1Y2UoKHN1bSwgc3ApID0+IHN1bSArIHNwLnF1YW50aXR5LCAwKTtcclxuICAgIH0sIDApO1xyXG4gIH0sXHJcbiAgXHJcbiAgZ2V0SXRlbU1vZGVsS2V5OiAoaXRlbTogSXRlbSk6IHN0cmluZyA9PiB7XHJcbiAgICByZXR1cm4gYCR7aXRlbS50eXBlfXwke2l0ZW0uc3ViSXRlbVR5cGUgfHwgJyd9fCR7aXRlbS5uYW1lfXwke2l0ZW0uY29sbGVjdGlvbiB8fCAnJ31gO1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gRmluYW5jaWFsIHJlY29yZHMgZmlsdGVyaW5nIG1ldGhvZHNcclxuICBnZXRGaW5hbmNpYWxSZWNvcmRzQnlNb250aDogYXN5bmMgKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgdHlwZTogJ2NvbXBhbnknIHwgJ3BlcnNvbmFsJyk6IFByb21pc2U8RmluYW5jaWFsUmVjb3JkW10+ID0+IHtcclxuICAgIGNvbnN0IGFsbFJlY29yZHMgPSBhd2FpdCBDbGllbnRBUEkuZ2V0RmluYW5jaWFsUmVjb3JkcygpO1xyXG4gICAgcmV0dXJuIGFsbFJlY29yZHMuZmlsdGVyKHJlY29yZCA9PiBcclxuICAgICAgcmVjb3JkLnllYXIgPT09IHllYXIgJiYgXHJcbiAgICAgIHJlY29yZC5tb250aCA9PT0gbW9udGggJiYgXHJcbiAgICAgIHJlY29yZC50eXBlID09PSB0eXBlXHJcbiAgICApO1xyXG4gIH0sXHJcblxyXG4gIC8vIEFkZGl0aW9uYWwgbWV0aG9kcyBuZWVkZWQgYnkgY29tcG9uZW50c1xyXG4gIGdldFF1YW50aXR5QXRTaXRlOiAoaXRlbTogSXRlbSwgc2l0ZUlkOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xyXG4gICAgcmV0dXJuIGl0ZW0uc3RvY2suZmluZChzcCA9PiBzcC5zaXRlSWQgPT09IHNpdGVJZCk/LnF1YW50aXR5IHx8IDA7XHJcbiAgfSxcclxuXHJcbiAgbW92ZUl0ZW1zQmV0d2VlblNpdGVzOiBhc3luYyAoaXRlbTogSXRlbSwgZnJvbVNpdGVJZDogc3RyaW5nLCB0b1NpdGVJZDogc3RyaW5nLCBxdWFudGl0eTogbnVtYmVyKTogUHJvbWlzZTxJdGVtPiA9PiB7XHJcbiAgICBjb25zdCB1cGRhdGVkSXRlbSA9IHsgLi4uaXRlbSB9O1xyXG4gICAgXHJcbiAgICAvLyBGaW5kIHNvdXJjZSBzdG9ja1xyXG4gICAgY29uc3Qgc291cmNlU3RvY2tJbmRleCA9IHVwZGF0ZWRJdGVtLnN0b2NrLmZpbmRJbmRleChzcCA9PiBzcC5zaXRlSWQgPT09IGZyb21TaXRlSWQpO1xyXG4gICAgaWYgKHNvdXJjZVN0b2NrSW5kZXggPT09IC0xKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBub3QgZm91bmQgYXQgc291cmNlIHNpdGU6ICR7ZnJvbVNpdGVJZH1gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3Qgc291cmNlU3RvY2sgPSB1cGRhdGVkSXRlbS5zdG9ja1tzb3VyY2VTdG9ja0luZGV4XTtcclxuICAgIGlmIChzb3VyY2VTdG9jay5xdWFudGl0eSA8IHF1YW50aXR5KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IHF1YW50aXR5IGF0IHNvdXJjZS4gQXZhaWxhYmxlOiAke3NvdXJjZVN0b2NrLnF1YW50aXR5fSwgUmVxdWVzdGVkOiAke3F1YW50aXR5fWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBSZWR1Y2Ugc291cmNlIHF1YW50aXR5XHJcbiAgICBpZiAoc291cmNlU3RvY2sucXVhbnRpdHkgPT09IHF1YW50aXR5KSB7XHJcbiAgICAgIC8vIFJlbW92ZSBzdG9jayBwb2ludCBpZiBtb3ZpbmcgYWxsIGl0ZW1zXHJcbiAgICAgIHVwZGF0ZWRJdGVtLnN0b2NrID0gdXBkYXRlZEl0ZW0uc3RvY2suZmlsdGVyKChfLCBpKSA9PiBpICE9PSBzb3VyY2VTdG9ja0luZGV4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFJlZHVjZSBxdWFudGl0eVxyXG4gICAgICB1cGRhdGVkSXRlbS5zdG9ja1tzb3VyY2VTdG9ja0luZGV4XSA9IHtcclxuICAgICAgICAuLi5zb3VyY2VTdG9jayxcclxuICAgICAgICBxdWFudGl0eTogc291cmNlU3RvY2sucXVhbnRpdHkgLSBxdWFudGl0eVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBZGQgdG8gZGVzdGluYXRpb24gKG9yIGluY3JlYXNlIGV4aXN0aW5nIHN0b2NrKVxyXG4gICAgY29uc3QgZGVzdFN0b2NrSW5kZXggPSB1cGRhdGVkSXRlbS5zdG9jay5maW5kSW5kZXgoc3AgPT4gc3Auc2l0ZUlkID09PSB0b1NpdGVJZCk7XHJcbiAgICBpZiAoZGVzdFN0b2NrSW5kZXggPj0gMCkge1xyXG4gICAgICAvLyBJbmNyZWFzZSBleGlzdGluZyBzdG9ja1xyXG4gICAgICB1cGRhdGVkSXRlbS5zdG9ja1tkZXN0U3RvY2tJbmRleF0gPSB7XHJcbiAgICAgICAgLi4udXBkYXRlZEl0ZW0uc3RvY2tbZGVzdFN0b2NrSW5kZXhdLFxyXG4gICAgICAgIHF1YW50aXR5OiB1cGRhdGVkSXRlbS5zdG9ja1tkZXN0U3RvY2tJbmRleF0ucXVhbnRpdHkgKyBxdWFudGl0eVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQWRkIG5ldyBzdG9jayBwb2ludFxyXG4gICAgICB1cGRhdGVkSXRlbS5zdG9jay5wdXNoKHtcclxuICAgICAgICBzaXRlSWQ6IHRvU2l0ZUlkLFxyXG4gICAgICAgIHF1YW50aXR5OiBxdWFudGl0eVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHVwZGF0ZWRJdGVtO1xyXG4gIH0sXHJcblxyXG4gIGJ1bGtJbXBvcnRJdGVtczogYXN5bmMgKGl0ZW1zOiBJdGVtW10pOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xyXG4gICAgICAgIGF3YWl0IENsaWVudEFQSS51cHNlcnRJdGVtKGl0ZW0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGJ1bGsgaW1wb3J0IGl0ZW1zOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGJ1bGtNZXJnZUl0ZW1zOiBhc3luYyAoaXRlbXM6IEl0ZW1bXSk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4gICAgY29uc29sZS53YXJuKCdbQ2xpZW50QVBJXSBidWxrTWVyZ2VJdGVtcyBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgYnVsa0FkZEl0ZW1zT25seTogYXN5bmMgKGl0ZW1zOiBJdGVtW10pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgYWRkZWRDb3VudDogbnVtYmVyIH0+ID0+IHtcclxuICAgIGNvbnNvbGUud2FybignW0NsaWVudEFQSV0gYnVsa0FkZEl0ZW1zT25seSBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgYWRkZWRDb3VudDogMCB9O1xyXG4gIH0sXHJcblxyXG4gIGdldEFjY291bnRzOiBhc3luYyAoKTogUHJvbWlzZTxhbnlbXT4gPT4ge1xyXG4gICAgY29uc29sZS53YXJuKCdbQ2xpZW50QVBJXSBnZXRBY2NvdW50cyBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfSxcclxuXHJcbiAgLy8gQlVMSyBPUEVSQVRJT04gTE9HR0lOR1xyXG4gIGxvZ0J1bGtJbXBvcnQ6IGFzeW5jIChlbnRpdHlUeXBlOiBzdHJpbmcsIGRldGFpbHM6IHsgY291bnQ6IG51bWJlcjsgc291cmNlPzogc3RyaW5nOyBpbXBvcnRNb2RlPzogJ2FkZCcgfCAnbWVyZ2UnIHwgJ3JlcGxhY2UnOyBleHRyYT86IGFueSB9KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9sb2dzL2J1bGsnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgIGVudGl0eVR5cGUsXHJcbiAgICAgICAgb3BlcmF0aW9uOiAnaW1wb3J0JyxcclxuICAgICAgICAuLi5kZXRhaWxzXHJcbiAgICAgIH0pXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2cgYnVsayBpbXBvcnQnKTtcclxuICB9LFxyXG5cclxuICBsb2dCdWxrRXhwb3J0OiBhc3luYyAoZW50aXR5VHlwZTogc3RyaW5nLCBkZXRhaWxzOiB7IGNvdW50OiBudW1iZXI7IGV4cG9ydEZvcm1hdD86IHN0cmluZzsgZXh0cmE/OiBhbnkgfSk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvbG9ncy9idWxrJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICBlbnRpdHlUeXBlLFxyXG4gICAgICAgIG9wZXJhdGlvbjogJ2V4cG9ydCcsXHJcbiAgICAgICAgLi4uZGV0YWlsc1xyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9nIGJ1bGsgZXhwb3J0Jyk7XHJcbiAgfSxcclxuXHJcbiAgLy8gUVVFVUUgTUFOQUdFTUVOVFxyXG4gIGdldFF1ZXVlU3RhdHVzOiBhc3luYyAoKTogUHJvbWlzZTxhbnk+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL3F1ZXVlL3N0YXR1cycpO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBxdWV1ZSBzdGF0dXMnKTtcclxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xyXG4gIH0sXHJcblxyXG4gIGNvbmZpZ3VyZVF1ZXVlOiBhc3luYyAob3B0aW9uczogeyBtYXhDb25jdXJyZW5jeT86IG51bWJlcjsgYmF0Y2hTaXplPzogbnVtYmVyIH0pOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL3F1ZXVlL2NvbmZpZ3VyZScsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcHRpb25zKVxyXG4gICAgfSk7XHJcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29uZmlndXJlIHF1ZXVlJyk7XHJcbiAgfSxcclxuXHJcbiAgc3RvcFF1ZXVlOiBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9xdWV1ZS9zdG9wJywgeyBtZXRob2Q6ICdQT1NUJyB9KTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdG9wIHF1ZXVlJyk7XHJcbiAgfSxcclxuXHJcbiAgY2xlYXJRdWV1ZTogYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvcXVldWUvY2xlYXInLCB7IG1ldGhvZDogJ1BPU1QnIH0pO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNsZWFyIHF1ZXVlJyk7XHJcbiAgfSxcclxufTtcclxuIl0sIm5hbWVzIjpbIkNsaWVudEFQSSIsImdldFRhc2tzIiwicmVzIiwiZmV0Y2giLCJvayIsIkVycm9yIiwianNvbiIsImdldFRhc2tCeUlkIiwiaWQiLCJ1cHNlcnRUYXNrIiwidGFzayIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRlbGV0ZVRhc2siLCJ1cHNlcnRUYXNrUXVldWVkIiwicHJpb3JpdHkiLCJyZXN1bHQiLCJxdWV1ZUlkIiwiZ2V0SXRlbXMiLCJnZXRJdGVtQnlJZCIsInVwc2VydEl0ZW0iLCJpdGVtIiwiZGVsZXRlSXRlbSIsInVwc2VydEl0ZW1RdWV1ZWQiLCJnZXRTYWxlcyIsImdldFNhbGVCeUlkIiwidXBzZXJ0U2FsZSIsInNhbGUiLCJkZWxldGVTYWxlIiwidXBzZXJ0U2FsZVF1ZXVlZCIsImdldEZpbmFuY2lhbFJlY29yZHMiLCJnZXRGaW5hbmNpYWxSZWNvcmRCeUlkIiwidXBzZXJ0RmluYW5jaWFsUmVjb3JkIiwicmVjb3JkIiwiZGVsZXRlRmluYW5jaWFsUmVjb3JkIiwidXBzZXJ0RmluYW5jaWFsUmVjb3JkUXVldWVkIiwiZ2V0Q2hhcmFjdGVycyIsImdldENoYXJhY3RlckJ5SWQiLCJ1cHNlcnRDaGFyYWN0ZXIiLCJjaGFyYWN0ZXIiLCJkZWxldGVDaGFyYWN0ZXIiLCJnZXRQbGF5ZXJzIiwiZ2V0UGxheWVyQnlJZCIsInVwc2VydFBsYXllciIsInBsYXllciIsImRlbGV0ZVBsYXllciIsImdldExpbmtzRm9yIiwicGFyYW1zIiwidHlwZSIsImNvbnNvbGUiLCJlcnJvciIsImdldEFsbExpbmtzIiwicmVtb3ZlTGluayIsImxpbmtJZCIsInJlbW92ZUxvZ0VudHJ5IiwibG9nVHlwZSIsImVudGl0eUlkIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJnZXRTaXRlcyIsImdldFNpdGVCeUlkIiwidXBzZXJ0U2l0ZSIsInNpdGUiLCJkZWxldGVTaXRlIiwiZ2V0QWNjb3VudCIsInVwc2VydEFjY291bnQiLCJhY2NvdW50IiwiZ2V0Q29tcGFueUFzc2V0cyIsInNhdmVDb21wYW55QXNzZXRzIiwiYXNzZXRzIiwiZ2V0UGVyc29uYWxBc3NldHMiLCJzYXZlUGVyc29uYWxBc3NldHMiLCJnZXRDb252ZXJzaW9uUmF0ZXMiLCJzYXZlQ29udmVyc2lvblJhdGVzIiwicmF0ZXMiLCJnZXRQb2ludHNDb252ZXJzaW9uUmF0ZXMiLCJnZXRJdGVtVG90YWxRdWFudGl0eSIsIml0ZW1JZCIsIml0ZW1zIiwiZmluZCIsImkiLCJzdG9jayIsInJlZHVjZSIsInN1bSIsInNwIiwicXVhbnRpdHkiLCJ1cGRhdGVTdG9ja0F0U2l0ZSIsInNpdGVJZCIsImN1cnJlbnRJdGVtIiwic3RvY2tJbmRleCIsImZpbmRJbmRleCIsInVwZGF0ZWRTdG9jayIsInNwbGljZSIsInB1c2giLCJjb252ZXJ0UG9pbnRzVG9KJCIsInBvaW50cyIsImNvbnZlcnNpb25SYXRlIiwiTWF0aCIsImZsb29yIiwiZ2V0SXRlbXNCeU1vZGVsIiwiZ3JvdXBlZCIsImZvckVhY2giLCJrZXkiLCJzdWJJdGVtVHlwZSIsIm5hbWUiLCJjb2xsZWN0aW9uIiwiZ2V0TW9kZWxUb3RhbFF1YW50aXR5Iiwic2VsZWN0ZWRTaXRlSWRzIiwidG90YWwiLCJzaXplIiwiZmlsdGVyIiwiaGFzIiwiZ2V0SXRlbU1vZGVsS2V5IiwiZ2V0RmluYW5jaWFsUmVjb3Jkc0J5TW9udGgiLCJ5ZWFyIiwibW9udGgiLCJhbGxSZWNvcmRzIiwiZ2V0UXVhbnRpdHlBdFNpdGUiLCJtb3ZlSXRlbXNCZXR3ZWVuU2l0ZXMiLCJmcm9tU2l0ZUlkIiwidG9TaXRlSWQiLCJ1cGRhdGVkSXRlbSIsInNvdXJjZVN0b2NrSW5kZXgiLCJzb3VyY2VTdG9jayIsIl8iLCJkZXN0U3RvY2tJbmRleCIsImJ1bGtJbXBvcnRJdGVtcyIsImJ1bGtNZXJnZUl0ZW1zIiwid2FybiIsImJ1bGtBZGRJdGVtc09ubHkiLCJhZGRlZENvdW50IiwiZ2V0QWNjb3VudHMiLCJsb2dCdWxrSW1wb3J0IiwiZW50aXR5VHlwZSIsImRldGFpbHMiLCJvcGVyYXRpb24iLCJsb2dCdWxrRXhwb3J0IiwiZ2V0UXVldWVTdGF0dXMiLCJjb25maWd1cmVRdWV1ZSIsIm9wdGlvbnMiLCJzdG9wUXVldWUiLCJjbGVhclF1ZXVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/client-api.ts\n"));

/***/ })

});