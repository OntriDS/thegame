'use client';

import { useState, useEffect, useMemo } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Edit2, Info } from 'lucide-react';
import { getZIndexClass } from '@/lib/utils/z-index-utils';

interface LogEntryEditModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  entry: any;
  entityType: string;
  onSave: (updates: Record<string, any>, reason?: string) => Promise<void>;
  isSaving?: boolean;
}

// Immutable/computed fields that cannot be edited
const IMMUTABLE_FIELDS = [
  'id', 'entityId', 'timestamp', 'event', 'editedAt', 'editedBy', 'lastUpdated', 
  'editHistory', 'isDeleted', 'deletedAt', 'deletedBy', 'deleteReason',
  // Computed fields (generated by processLogData)
  'displayName', 'currentStatus', 'formattedDate', 'formattedTime', 'displayDate'
];

// Priority fields shown first
const PRIORITY_FIELDS = ['name', 'description', 'taskType', 'status', 'priority', 'station'];

export function LogEntryEditModal({
  open,
  onOpenChange,
  entry,
  entityType,
  onSave,
  isSaving = false
}: LogEntryEditModalProps) {
  const [formData, setFormData] = useState<Record<string, any>>({});
  const [reason, setReason] = useState('');
  
  // Get editable fields from entry, intelligently sorted
  const editableFields = useMemo(() => {
    if (!entry) return [];
    
    return Object.keys(entry)
      .filter(key => !IMMUTABLE_FIELDS.includes(key))
      .sort((a, b) => {
        const aPriority = PRIORITY_FIELDS.indexOf(a);
        const bPriority = PRIORITY_FIELDS.indexOf(b);
        
        // Priority fields first
        if (aPriority !== -1 && bPriority !== -1) return aPriority - bPriority;
        if (aPriority !== -1) return -1;
        if (bPriority !== -1) return 1;
        
        // Then alphabetical
        return a.localeCompare(b);
      });
  }, [entry]);
  
  // Initialize form when entry changes
  useEffect(() => {
    if (entry) {
      const initialData: Record<string, any> = {};
      editableFields.forEach(field => {
        initialData[field] = entry[field];
      });
      setFormData(initialData);
      setReason('');
    }
  }, [entry, editableFields]);

  // Check if there are any changes
  const hasChanges = () => {
    if (!entry) return false;
    
    for (const field of editableFields) {
      const currentValue = formData[field];
      const originalValue = entry[field];
      
      if (currentValue !== originalValue && 
          !(currentValue == null && originalValue == null)) {
        return true;
      }
    }
    return false;
  };

  const handleFieldChange = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  const handleSave = async () => {
    if (!hasChanges()) {
      onOpenChange(false);
      return;
    }

    const updates: Record<string, any> = {};
    for (const field of editableFields) {
      const currentValue = formData[field];
      const originalValue = entry[field];
      
      if (currentValue !== originalValue) {
        updates[field] = currentValue;
      }
    }

    await onSave(updates, reason.trim() || undefined);
  };

  // Smart field rendering with proper sizing
  const renderField = (field: string, value: any) => {
    const stringValue = value != null ? String(value) : '';
    const isLong = stringValue.length > 100;
    
    if (isLong) {
      return (
        <Textarea
          id={field}
          value={stringValue}
          onChange={(e) => handleFieldChange(field, e.target.value)}
          disabled={isSaving}
          rows={3}
          className="resize-none"
        />
      );
    }
    
    return (
      <Input
        id={field}
        value={stringValue}
        onChange={(e) => handleFieldChange(field, e.target.value)}
        disabled={isSaving}
      />
    );
  };

  // Format field labels
  const formatLabel = (field: string) => {
    // Convert camelCase/PascalCase to Title Case
    return field
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .trim();
  };

  if (!entry) return null;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className={`max-w-4xl ${getZIndexClass('SUB_MODALS')}`}>
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Edit2 className="h-5 w-5 text-blue-600" />
            Edit Log Entry
          </DialogTitle>
        </DialogHeader>
        
        <div className="space-y-4">
          {/* Compact metadata header */}
          <div className="flex items-center gap-4 p-3 bg-muted/30 rounded-lg border border-dashed text-xs text-muted-foreground">
            <div className="flex items-center gap-1">
              <Info className="h-3 w-3" />
              <span className="font-medium">Event:</span> {entry.event || 'N/A'}
            </div>
            <span>•</span>
            <div>
              <span className="font-medium">Date:</span> {entry.timestamp || 'N/A'}
            </div>
            <span>•</span>
            <div className="truncate">
              <span className="font-medium">Entity:</span> {entry.entityId?.substring(0, 16)}...
            </div>
          </div>

          {/* Two-column editable fields layout */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 max-h-[50vh] overflow-y-auto pr-2">
            {editableFields.map(field => {
              const value = formData[field];
              const isRequired = field === 'name';
              
              return (
                <div key={field} className={field === 'description' ? 'md:col-span-2' : ''}>
                  <Label 
                    htmlFor={field} 
                    className={`text-xs ${isRequired ? "after:content-['*'] after:ml-0.5 after:text-red-500" : ""}`}
                  >
                    {formatLabel(field)}
                  </Label>
                  {renderField(field, value)}
                </div>
              );
            })}
          </div>

          {/* Reason for edit */}
          <div className="pt-2 border-t">
            <Label htmlFor="reason" className="text-xs">
              Reason for Edit <span className="text-muted-foreground">(Optional)</span>
            </Label>
            <Input
              id="reason"
              value={reason}
              onChange={(e) => setReason(e.target.value)}
              disabled={isSaving}
              placeholder="Why are you editing this entry?"
              className="mt-1"
            />
          </div>

          {/* No changes indicator */}
          {!hasChanges() && (
            <div className="flex items-center gap-2 p-2 bg-yellow-50 dark:bg-yellow-950/20 border border-yellow-200 dark:border-yellow-900 rounded-md text-xs text-yellow-800 dark:text-yellow-200">
              <Info className="h-3 w-3 flex-shrink-0" />
              <span>No changes detected</span>
            </div>
          )}
        </div>

        <DialogFooter className="gap-2">
          <Button variant="outline" onClick={() => onOpenChange(false)} disabled={isSaving}>
            Cancel
          </Button>
          <Button 
            onClick={handleSave}
            disabled={isSaving || !hasChanges()}
            className="bg-blue-600 hover:bg-blue-700"
          >
            {isSaving ? 'Saving...' : 'Save Changes'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

